PVector[] enemyPosition;

int resource = 0;
long time;
int towerPanel = 0;

void setup() {
  size(1366, 768);
  
  enemyPosition = new PVector[10];
  for (int i = 0; i < enemyPosition.length; i ++) {
    float x = random(0, width);
    float y = random(0, height);
    enemyPosition[i] = new PVector(x,y);
  }  
}

void draw() {
  background(#cc9900);
  
  //resources;
  fill(#000000);
  textSize(32);
  text(resource, 0, 32);
  
  if (millis() - time > 5000) {
    resource += 50;
    time = millis();
  }
  
  //grid row 1
  for (int i = 50; i <= 866; i += 136) {
    fill(#996633);
    rect(i, 50, 136, 136);
  }
  //grid row 2
  for (int i = 50; i <= 866; i += 136) {
    fill(#996633);
    rect(i, 186, 136, 136);
  }  
  //grid row 3
  for (int i = 50; i <= 866; i += 136) {
    fill(#996633);
    rect(i, 322, 136, 136);
  }  
  //grid row 4
  for (int i = 50; i <= 866; i += 136) {
    fill(#996633);
    rect(i, 458, 136, 136);
  }  
  //grid row 5
  for (int i = 50; i <= 866; i += 136) {
    fill(#996633);
    rect(i, 594, 136, 136);
  }  

  // enemy
  
  // change location
  for (int i = 0; i < enemyPosition.length; i++) {
     enemyPosition[i].add(- 1, 0);
     
     // boundary check
     if (enemyPosition[i].x - 105 > width) {
       enemyPosition[i].x = - 105;
       enemyPosition[i].y = (int) random(50, 400);
     }
     
     // drawing enemy
       fill(#C0C0C0);
       rect(enemyPosition[i].x, enemyPosition[i].y, 100, 100);
  }
}  

void mouseClicked() {
  // towers

}
